
# ----------------- SEGMENTATION ----------------- #

# Parameters for watershed
# normalize_func : Function to perform image normalization for example gamma, sigmoid
# contrast_adjustment_func: Function to adjust/balance the contract of the image
# blur_func: Funtion to blurr the image
# threshold_func: Funtions to find the masking threshold for the image to apply on watershed
# distance_transform_func: Function to perfrom distance_transform
# local_maxima_func: Function to find local maximum as marker for watershed
# post_processing_func: Function to perfrom image processing after segmentation


# Default parameters for pre-processing functions

# normalize
# adjust_gamma(image, gamma=1, gain=1)
# adjust_log(image, gain=1, inv=False)
# adjust_sigmoid(image, cutoff=0.5, gain=10, inv=False)

# contrast adjustment
# equalize_adapthist(image, kernel_size=None, clip_limit=0.01, nbins=256)
# equalize_hist(image, nbins=256, mask=None)
# rescale_intensity(image, in_range='image', out_range='dtype')

# blur
# gaussian(image, sigma=1, output=None, mode='nearest', cval=0, preserve_range=False, truncate=4.0, *, channel_axis=<ChannelAxisNotSet>)
# median(image, footprint=None, out=None, mode='nearest', cval=0.0, behavior='ndimage')


# threshold
# threshold_otsu(image=None, nbins=256, *, hist=None)
# threshold_triangle(image, nbins=256)
# rank.otsu(image, footprint, out=None, mask=None, shift_x=False, shift_y=False, shift_z=False)


# distance transform
# distance_transform_edt(input, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None)


# local maxima
# find_local_maxima(distance_transform, min_distance=5)


# post processing
# remove_small_objects(ar, min_size=64, connectivity=1, *, out=None)


watershed:
  normalize_func: "gamma"
  normalize_gamma: 1
  normalize_gain: 1
  normalize_inv: False
  normalize_cutoff: 0.5

  contrast_adjustment_func: "equalize_adapthist"
  contrast_adjustment_kernel_size: None
  contrast_adjustment_clip_limit: 0.01
  contrast_adjustment_nbins: 256
  contrast_adjustment_mask: None
  contrast_adjustment_in_range: "image"
  contrast_adjustment_out_range: "dtype"

  blur_func: "gaussian"
  blur_sigma: 1
  blur_output: None
  blur_mode: 'nearest'
  blur_cval: 0
  blur_preserve_range: False
  blur_truncate: 4.0
  blur_footprint: None
  blur_out: None
  blur_behavior: 'ndimage'

  threshold_func: "otsu"
  threshold_nbins: 256
  threshold_hist: None
  threshold_out: None
  threshold_mask: None
  threshold_shift_x: False
  threshold_shift_y: False
  threshold_shift_z: False
  threshold_footprint: "square"
  threshold_footprint_size: 10

  distance_transform_func: "distance_transform_edt"
  distance_transform_sampling: None
  distance_transform_return_distances: True
  distance_transform_return_indices: False
  distance_transform_distances: None
  distance_transform_indices: None
  
  local_maxima_func: "find_local_maxima"
  local_maxima_min_distance: 5

  post_processing_func_1: "remove_small_objects"
  post_processing_min_size_1: 64
  post_processing_connectivity_1: 1
  post_processing_out_1: None

  post_processing_func_2: "remove_small_holes"
  post_processing_area_threshold_2: 64
  post_processing_connectivity_2: 1
  post_processing_out_2: None


# Parameters for cellpose

## Parameter used in GUI

# flow_threshold: Flow error threshold. Cells with errors below this threshold are retained. A higher threshold may keep more cells but some may be poorly segmented.

# cellprob_threshold: Pixels with value above this threshold are kept for masks. A lower threshold can find more and larger masks.

# stitch_threshold: If this value is more than 0.0, not do_3D, and image sizes are equal, masks are stitched in 3D to return volume segmentation. A higher threshold results in more stitching but can create larger segments.

# channels: A list indicating which channels to segment. None means all channels will be segmented. The number and choice of channels can affect segmentation results.

## Detailed Parameter

# z_axis: Axis index for the Z (depth) dimension. None implies it will be determined automatically. Important for 3D images.

# normalize: If True, normalize image so that 0.0 corresponds to 1st percentile and 1.0 corresponds to 99th percentile of image intensities in each channel. This can enhance contrast and improve segmentation.

# invert: If True, invert image pixel intensity before running network. This can be beneficial when objects of interest are dark on a light background.

# rescale: Rescale factor applied if diameter is not provided. None implies it will be estimated automatically. This could affect cell size in final segmentation.

# diameter (pixel): Estimated cell diameter. None implies diameter will be estimated automatically. Affects the size of cells in segmentation.

# do_3D: If True, run 3D segmentation on 4D image input. Determines the dimensionality of the segmentation.

# anisotropy: Rescaling factor for 3D segmentation. None implies no rescaling. Important when Z spacing is different from X or Y spacing.

# net_avg: If True, runs the 4 built-in networks and averages the results. If False, runs a single network. Multiple networks may increase accuracy but take more time.

# augment: If True, augment the image by tiling with overlapping tiles and flipping overlapped regions. This can enhance the robustness of the segmentation but requires more computation.

# tile: If True, tile the image to ensure GPU/CPU memory usage is limited. Prevents out-of-memory errors.

# tile_overlap: Determines the fraction of overlap of tiles when computing flows. A larger overlap may improve consistency at the expense of increased computation.

# resample: If True, run dynamics at the original image size. May improve segmentation accuracy but be slower.

# interp: If True, interpolate during 2D dynamics. Not available for 3D. May improve segmentation accuracy but be slower.

# min_size: Minimum number of pixels per mask. A smaller value may yield more but smaller segments.

# progress: PyQt progress bar. None means no progress bar will be shown.

# loop_run: If True, continue running the loop until the model is loaded. Useful for preventing early termination.

# model_loaded: If True, the model is already loaded. Useful for saving loading time when repeatedly running the segmentation.

cellpose:
  model_type: None
  batch_size: 8
  channels: None
  channel_axis: None
  z_axis: None
  normalize: True
  invert: False
  rescale: None
  diameter: None
  do_3D: False
  anisotropy: None
  net_avg: False
  augment: False
  tile: False
  tile_overlap: 0.1
  resample: True
  interp: False
  flow_threshold: 0.4
  cellprob_threshold: 0.0
  min_size: 15
  stitch_threshold: 0.0 # Only for 3D data
  progress: None
  loop_run: False
  model_loaded: False

segmentation_params:
  expand: 0 #SCALE PARAM


# ----------------- ASSIGNMENT ----------------- #

# Model input params:

# spots: pandas DataFrame.
# dapi: numpy array.
# gene_list: numpy array. An array of gene id values.
# num_dims: int. Number of data dimensions, 2 or 3.
# model_xy_radius: float. Estimation of radius of cells in x-y plane.
# model_z_radius: float. Estimation of radius of cells in z axis; 0 if data is 2D.
# model_gauss_blur: bool. Choose whether to apply Gaussian blur with sigma=model_sigma.
# model_sigma: float. Sigma value for Gaussian blur.
# model_fast_preprocess: bool. Binarize DAPI images with erosion and morphological reconstruction before OTSU thresholding when True. Binarize DAPI images with only OTSU thresholding when False.
# model_trim: Trimming and stitching functions to process over each trimmed tile to save computational resources.
# model_window_size : window size for trimming and stitching

# Preprocess params:
# preprocess_dapi_grid_interval: Sample interval in DAPI image.
# preprocess_pct_filter: Controls the threshold for marking points as noise based on the percentile of the distances distribution.
# preprocess_LOF: Use Unsupervised Outlier Detection using the LocalOutlierFactor (LOF) from sklearn.neighbors in preprocessing
# preprocess_contamination: LOF dependent. The amount of contamination of the data set, i.e. the proportion of outliers in the data set. When fitting this is used to define the threshold on the scores of the samples. should be in the range (0, 0.5]

# Segmentation params:
# segmentation_min_spot_per_cell: Erase clusters with less than this number of spots.
# segmentation_cell_num_threshold: A threshold for deciding the number of cells using lambda curve. ρ (Density), δ (Distance), Lambda := λ=ρ⋅δ or λ=ln(ρ)⋅δ
# segmentation_dapi_grid_interval: Pick every nth point from this grid (like picking every 5th point if the interval is 5) to reduce the amount of data we have to process, making the analysis quicker.
# segmentation_add_dapi: Whether or not to add Dapi points for (Density Peak Clustering) DPC
# segmentation_use_genedis: Whether or not to ise gene ids for (Density Peak Clustering) DPC

## recommanded combination model_fast_preprocess = True and model_gauss_blur = False
## recommanded combination model_fast_preprocess = False and model_gauss_blur = True

clustermap:

  #model_dapi: None #not hyperparameter
  #model_num_dims: 2  #not hyperparameter
  model_xy_radius: 40
  model_z_radius: 0
  model_fast_preprocess: False 
  model_gauss_blur: True
  model_sigma: 1
  model_window_size: 1000
  model_trim: False

  preprocess_window_size: 1000
  preprocess_dapi_grid_interval: 5
  preprocess_contamination: 0
  preprocess_pct_filter: 0.05
  preprocess_LOF: False

  segmentation_min_spot_per_cell: 10
  segmentation_cell_num_threshold: 0.01
  segmentation_dapi_grid_interval: 5
  segmentation_add_dapi: True
  segmentation_use_genedis: True


# ----------------- ASSIGNMENT ----------------- #

pciSeq:
  # list of genes to be excluded during cell-typing, e.g ['Aldoc', 'Id2'] to exclude all spots from Aldoc and Id2
  exclude_genes: None

  # Maximum number of loops allowed for the Variational Bayes to run
  max_iter: 1000

  # Convergence achieved if assignment probabilities between two successive loops is less than the tolerance
  CellCallTolerance: 0.02

  # A gamma distribution expresses the efficiency of the in-situ sequencing for each gene. It tries to capture
  # the ratio of the observed over the theoretical counts for a given gene. rGene controls the variance and
  # Inefficiency is the average of this assumed Gamma distribution
  rGene: 20
  Inefficiency: 0.2

  # If a spot is inside the cell boundaries this bonus will give the likelihood an extra boost
  # in order to make the spot more probable to get assigned to the cell than another spot positioned
  # outside the cell boundaries
  InsideCellBonus: 2

  # To account for spots far from the some a uniform distribution is introduced to describe those misreads.
  # By default this uniform distribution has a density of 1e-5 misreads per pixel.
  MisreadDensity: 0.00001

  # Gene detection might come with irregularities due to technical errors. A small value is introduced
  # here to account for these errors. It is an additive factor, applied to the single cell expression
  # counts when the mean counts per class and per gene are calculated.
  SpotReg: 0.1

  # By default only the 3 nearest cells will be considered as possible parent cells for any given spot.
  # There is also one extra 'super-neighbor', which is always a neighbor to the spots so we can assign
  # the misreads to. Could be seen as the background. Hence, by default the algorithm tries examines
  # whether any of the 3 nearest cells is a possible parent cell to a given cell or whether the spot is
  # a misread
  nNeighbors: 3

  # A gamma distributed variate from Gamma(rSpot, 1) is applied to the mean expression, hence the counts
  # are distributed according to a Negative Binomial distribution.
  # The value for rSpot will control the variance/dispersion of the counts
  rSpot: 2

  # Boolean, if True the output will be saved as tsv files in a folder named 'pciSeq' in your system's temp dir.
  save_data: False

  # output directory 'default' will save to temp location
  output_path: ['default']

  # Use either np.float16 or np.float32 to reduce memory usage. In most cases RAM consumption shouldnt
  # need more than 32Gb RAM. If you have a dataset from a full coronal mouse slice with a high number of
  # segmented cells (around 150,000) a gene panel of more than 250 genes and 100 or more different
  # cell types (aka clusters, aka classes) in the single cell data then you might need at least 64GB on
  # your machine. Changing the datatype to a float16 or float32 will help keeping RAM usage to a lower
  # level
  dtype: np.float64

baysor:
  # Taken from https://github.com/kharchenkolab/Baysor/blob/master/configs/example_config.toml
  
  # [Data]
  # Name of the x column in the input data. Default: "x"
  x-column : '"x"'
  # Name of the y column in the input data. Default: "y"
  y-column : '"y"'
  # Name of the y column in the input data. Default: "z"
  z-column : '"z"'
  # Name of gene column in the input data. Default: "gene"
  gene-column : '"Gene"'
  # Minimal number of molecules per gene. Default: 1
  min-molecules-per-gene : 1
  # Minimal number of molecules for a cell to be considered as real. It's an important parameter, as it's used to infer several other parameters. Default: 3
  min-molecules-per-cell : 3
  # Scale parameter, which suggest approximate cell radius for the algorithm. This parameter is required.
  scale : 50 #SCALE PARAM
  # Standard deviation of scale across cells. Can be either number, which means absolute value of the std, or string ended with "%" to set it relative to scale. Default: "25%"
  # "scale-std" : '"25%"',
  
  # Not exactly sure if this one should be in [Data], therefore we don't provide it via the toml, so not possibl issues here.
  prior-segmentation-confidence : 0.2
  
  # # Use scale estimate from DAPI if provided. Default: true
  # "estimate-scale-from-centers" : "true",
  # # Minimal number of molecules in a segmented region, required for this region to be considered as a possible cell. Default: min-molecules-per-cell / 4
  # # "min-molecules-per-segment" : 2, # TODO: throws Error ErrorException("Unexpected value in the config: 'min-molecules-per-segment'")
  # 
  # #[Sampling] These parameters shouldn't normally be changed
  # # Prior weight of assignment a molecule to new component. Default: 0.2
  # "new-component-weight" : 0.2,
  # # Fraction of distributions, sampled at each stage. Default: 0.3
  # "new-component-fraction" : 0.3,
  
  #[Plotting]
  # Number of neighbors (i.e. 'k' in k-NN), which is used for gene composition visualization. Larger numbers leads to more global patterns. Default: estimate from min-molecules-per-cell
  # "gene-composition-neigborhood" : 20, # TODO: ErrorException("Unexpected value in the config: 'gene-composition-neigborhood'")
  # Number of pixels per cell of minimal size, used to estimate size of the final plot. For most protocols values around 7-30 give enough visualization quality. Default: 15
  # "min-pixels-per-cell" : 15, # TODO: didn't check this one, plotting is not so important i guess
  
basic:
  dummy_param: 0

# ----------------- NORMALIZATION ----------------- #


#other params?
area:
  alpha: 0
  use_max_area: True

total:
  find_area: False
  use_max_area: True

normalize_params:
  max_area: None
  min_area: None
  min_counts: 10
  min_cell_percentage: 0.8

# ----------------- ANNOTATION ----------------- #
majority:
  threshold: 0.7

ssam:
  threshold: 0.7

pciSeqCT:
  threshold: 0.7

annotation_params:
  per_gene_correction: False
  per_gene_layer: lognorm
